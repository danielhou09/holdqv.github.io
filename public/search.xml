<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java如何创建多线程?</title>
      <link href="2023/03/14/java-thread/"/>
      <url>2023/03/14/java-thread/</url>
      
        <content type="html"><![CDATA[<h2 id="继承-Thread-重新-run"><a href="#继承-Thread-重新-run" class="headerlink" title="继承 Thread,重新 run"></a>继承 Thread,重新 run</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承 Thread 类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程名&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,开始运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现-Runable-重写-run"><a href="#实现-Runable-重写-run" class="headerlink" title="实现 Runable+重写 run"></a>实现 Runable+重写 run</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现  Runnable 接口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;线程名&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,开始运行&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="实现-Callable-接口重写-call-方法"><a href="#实现-Callable-接口重写-call-方法" class="headerlink" title="实现 Callable 接口重写 call 方法"></a>实现 Callable 接口重写 call 方法</h2><p>获取返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Callable 接口 获取返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程名&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,开始运行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new-Thread-lamda-表达式"><a href="#new-Thread-lamda-表达式" class="headerlink" title="new Thread+lamda 表达式"></a>new Thread+lamda 表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 Thread 对象 lambda 表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程名&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,开始运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 基于线程池创建线程</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 集成 OpenAPI</title>
      <link href="2023/03/07/springdoc/"/>
      <url>2023/03/07/springdoc/</url>
      
        <content type="html"><![CDATA[<h2 id="1-项目介绍"><a href="#1-项目介绍" class="headerlink" title="1. 项目介绍"></a>1. 项目介绍</h2><p>本项目是一个基于SpringBoot的项目，用于演示如何使用SpringBoot集成open-api，包括swagger3和springdoc。</p><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><ul><li>jdk版本：openjdk19</li><li>springboot版本：3.0.4.RELEASE</li><li>springdoc版本：2.0.2</li></ul><h2 id="简单步骤"><a href="#简单步骤" class="headerlink" title="简单步骤"></a>简单步骤</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编写controller"><a href="#编写controller" class="headerlink" title="编写controller"></a>编写controller</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Operation(summary &#x3D; &quot;Get specific user object by it&#39;s id.&quot;)</span><br><span class="line">   @GetMapping(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">   public User user(@Parameter(description &#x3D; &quot;id of the user.&quot;) @PathVariable(&quot;id&quot;) long id) &#123;</span><br><span class="line"></span><br><span class="line">       User user &#x3D; new User();</span><br><span class="line">       user.setName(&quot;xxx&quot;);</span><br><span class="line">       return user;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用 openapi 的好处就是不需要额外的额皮质,使用swagger3的时候会增加 config 这里不需要.</p><h3 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址:"></a>访问地址:</h3><p>默认地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># swagger-ui custom path</span><br><span class="line">springdoc.swagger-ui.path&#x3D;&#x2F;swagger-ui.html</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接访问<br><code>http://localhost:8080/swagger-ui/index.html </code>效果如下:</p><p><img src="https://user-images.githubusercontent.com/9412449/223302078-7e443ea2-8bc0-49bb-ad23-a12046e3a290.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openapi </tag>
            
            <tag> swagger3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞定 数据库索引</title>
      <link href="2023/02/28/index/"/>
      <url>2023/02/28/index/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>数据库索引是一种数据结构，用于加快对数据库表中数据的检索速度。它可以把数据库表中的一列或多列数据作为索引键，并在索引键上建立一个索引树，以加快对数据的检索速度。</p><h3 id="索引越多越好吗"><a href="#索引越多越好吗" class="headerlink" title="索引越多越好吗?"></a>索引越多越好吗?</h3><p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="按用途分"><a href="#按用途分" class="headerlink" title="按用途分"></a>按用途分</h3><ol><li><p>普通索引（Normal Index）：普通索引是最常用的索引类型，它是按照索引列的值来建立索引的，它可以加快查询的速度，提高查询效率。</p></li><li><p>唯一索引（Unique Index）：唯一索引也是按照索引列的值来建立索引的，但是它的特点是索引列的值必须是唯一的，也就是说，在一个表中，索引列的值不能重复。</p></li><li><p>主键索引（Primary Key Index）：主键索引也是按照索引列的值来建立索引的，但是它的特点是索引列的值必须是唯一的，而且不能为空。</p></li><li><p>组合索引（Composite Index）：组合索引是指在一个表中，使用多个字段来建立索引，这样可以提高查询的效率。</p></li><li><p>全文索引（Full Text Index）：全文索引是指在一个表中，使用全文检索的方式来建立索引，这样可以提高查询的效率。</p></li></ol><p>底层原理：MySQL 索引的底层原理是使用 B-Tree（B 树）来存储索引，B-Tree 是一种特殊的树结构，它可以提供快速的查找、插入和删除操作，从而提高查询的效率。</p><h3 id="按数据结构分"><a href="#按数据结构分" class="headerlink" title="按数据结构分"></a>按数据结构分</h3><p>索引分类从数据结构上分为：</p><ol><li><p>线性索引：按照顺序存储数据，比如数组、链表等；</p></li><li><p>树形索引：按照树形结构存储数据，比如二叉树、B树等；</p></li><li><p>哈希索引：按照哈希函数存储数据，比如哈希表等；</p></li><li><p>全文索引：按照文本的全文检索原理存储数据，比如倒排索引等。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h2 id="索引规则"><a href="#索引规则" class="headerlink" title="索引规则"></a>索引规则</h2></li></ol><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><h3 id="索引失效原因"><a href="#索引失效原因" class="headerlink" title="索引失效原因"></a>索引失效原因</h3><ol><li><p><strong>索引被删除</strong>：当索引被删除时，索引就会失效。</p></li><li><p>索引被修改：当索引被修改时，索引也会失效。</p></li><li><p>数据发生变化：当数据发生变化时，索引也会失效。</p></li><li><p>索引字段被<strong>修改</strong>：当索引字段被修改时，索引也会失效。</p></li><li><p>索引被<strong>禁用</strong>：当索引被禁用时，索引也会失效。</p></li></ol><h3 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h3><ol><li><p>尽量减少索引的<strong>更新操作</strong>，因为更新操作会导致索引失效。</p></li><li><p><strong>尽量使用唯一索引</strong>，因为唯一索引可以避免重复记录，从而避免索引失效。</p></li><li><p>尽量使用<strong>复合索引</strong>，复合索引可以提高查询效率，也可以避免索引失效。</p></li><li><p>尽量使用<strong>覆盖索引</strong>，覆盖索引可以减少查询操作，从而避免索引失效。</p></li><li><p>尽量使用稳定的索引，稳定的索引可以<strong>避免数据变动</strong>，从而避免索引失效。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgresql 和mysql 对比</title>
      <link href="2023/02/28/psotgresvsmysql/"/>
      <url>2023/02/28/psotgresvsmysql/</url>
      
        <content type="html"><![CDATA[<p>postgresql 和mysql 对比</p><table><thead><tr><th align="left"></th><th align="left">PostgreSQL</th><th align="left">MySQL</th></tr></thead><tbody><tr><td align="left">数据类型</td><td align="left">支持复杂的数据类型，如数组，多维数组，对象，XML</td><td align="left">支持常见的数据类型，如数字，字符串，日期等</td></tr><tr><td align="left">事务支持</td><td align="left">支持ACID事务</td><td align="left">支持ACID事务</td></tr><tr><td align="left">存储过程</td><td align="left">支持存储过程</td><td align="left">支持存储过程</td></tr><tr><td align="left">视图</td><td align="left">支持视图</td><td align="left">支持视图</td></tr><tr><td align="left">触发器</td><td align="left">支持触发器</td><td align="left">支持触发器</td></tr><tr><td align="left">索引</td><td align="left">支持多种索引，如B树，哈希，GIST，GiST</td><td align="left">支持B树索引</td></tr><tr><td align="left">性能</td><td align="left">高性能</td><td align="left">中等性能</td></tr><tr><td align="left">安全性</td><td align="left">支持完整的安全性功能，如访问控制，加密，身份验证等</td><td align="left">支持完整的安全性功能，如访问控制，加密，身份验证等</td></tr><tr><td align="left">可移植性</td><td align="left">支持多种操作系统，如Linux，Windows，Mac OS等</td><td align="left">支持多种操作系统，如Linux，Windows，Mac OS等</td></tr><tr><td align="left">开源</td><td align="left">开源</td><td align="left">非开源</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些实用的 tips</title>
      <link href="2023/02/28/tips/"/>
      <url>2023/02/28/tips/</url>
      
        <content type="html"><![CDATA[<p> 记录一些比较实用的 tips.</p><h2 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h2><p> mac 一定要用这个,好的工具都这里了.</p><h2 id="chatgpt"><a href="#chatgpt" class="headerlink" title="chatgpt"></a>chatgpt</h2><p> 一些能那里直接用的答案.</p><h2 id="podcast"><a href="#podcast" class="headerlink" title="podcast"></a>podcast</h2><p> 一些播客很有必要听一下.</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 自旋锁 SpinLock</title>
      <link href="2023/02/25/spinlock/"/>
      <url>2023/02/25/spinlock/</url>
      
        <content type="html"><![CDATA[<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>线程等待加锁时，<strong>不会阻塞</strong>，<strong>不会进入等待状态</strong>，<strong>而是保持运行状态</strong>。大致的思路是：让当前线程不停地的在循环体内执行，当循环的条件被其他线程改变时才能进入临界区。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li><p>避免死锁<br>自旋锁不会让线程阻塞或等待，也就不需要唤醒，所以可以避免产生死锁；</p></li><li><p>提高性能<br>减少上下文切换次数,提高效率.</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2></li><li><p>在等待锁时进入循环会占用CPU，若等待的线程很多，对CPU的消耗会比较大；</p></li><li><p>不适合需要长时间等待的任务或线程；</p></li><li><p>不适合大量线程等待的场景。</p></li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>等待时间比较短的任务中；</li><li>线程数量不太多的应用中；</li><li>当等待时间长或线程数量很大时，可以使用其他锁（比如：可重入锁）。</li></ul><h2 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SpinkLock &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 是否占用的标志</span><br><span class="line">    private AtomicBoolean occupied &#x3D; new AtomicBoolean(false);</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用自旋锁</span><br><span class="line">        while (occupied.getAndSet(true)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        occupied.set(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 相比 Memcached 有哪些优势？</title>
      <link href="2023/02/24/cachecompare/"/>
      <url>2023/02/24/cachecompare/</url>
      
        <content type="html"><![CDATA[<p>Redis 和 Memcached 都是内存中的键值存储系统，它们都可以用于缓存、会话存储等场景，但是 Redis 相对于 Memcached 有以下几个优势：</p><ol><li><p>数据结构更丰富：Redis 支持更多的数据结构，如字符串、哈希表、列表、集合、有序集合等，这些数据结构可以方便地解决各种复杂的问题，如计数器、排行榜、社交网络、消息队列等。</p></li><li><p>更高的可靠性：Redis 支持数据持久化，可以将数据写入磁盘，即使服务器重启，数据也不会丢失。同时 Redis 支持主从复制和 Sentinel 高可用方案，可以保证服务的可靠性。</p></li><li><p>更好的性能表现：Redis 采用单线程的方式来处理请求，避免了多线程之间的锁竞争和上下文切换的开销，同时采用了多种优化技术，如内存池、事件驱动等，使得 Redis 在吞吐量和响应时间方面表现更好。</p></li></ol><p>更灵活的分布式方案：Redis 提供了分片和集群两种分布式方案，分片可以水平扩展，支持更大的数据量，集群则可以自动化地完成数据分片、数据迁移和故障转移等任务，使得 Redis 更容易应对高并发和海量数据的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习是在学什么</title>
      <link href="2023/02/24/studywhat/"/>
      <url>2023/02/24/studywhat/</url>
      
        <content type="html"><![CDATA[<p>我们不只是在求学过程中学习,从我们来到世上之后,从家庭,学校,社会上一直在主动或者被动接受各种知识,那么我们是为什么学习呢?</p><h2 id="知识改变命运"><a href="#知识改变命运" class="headerlink" title="知识改变命运"></a>知识改变命运</h2><p>有人说我就是为了考大学,考了大学为了找好工作,工作学习是为了涨工资,等等等等,其实都对那么本质是为啥呢?都说高考是唯一一次公平的竞争,底层人民的孩子改变命运的唯一一次翻牌的机会了.  改变命运之后呢?</p><h2 id="为了看清世界"><a href="#为了看清世界" class="headerlink" title="为了看清世界"></a>为了看清世界</h2><p>我们不只是在求学过程中学习,在我们来到世上之后,从家庭学校社会上一直再主动或者被动接受各种知识,有客观的自然规律,有人问的艺术细胞,还有人类智慧结晶.<br>最终都将是我们成为更好的自己.</p><p>学习能让我们看清世界,认识世界,了解世界.<br>学习能让我们认识自我,看清自我.<br>学习是在学什么?</p><h2 id="为了解决问题"><a href="#为了解决问题" class="headerlink" title="为了解决问题"></a>为了解决问题</h2><p>其实, 人生就像是操作系统一直在运作,唯独不同的是一旦关机后,会不会有上帝给你重启那就是另外一件事了.<br>起码我们假死的时候,自己可以杀掉进程,重新打开软件.<br>所以学习的最终目的就是解决问题,也就是产品上 解决bug.<br>人生来就是要俩解决各种问题的,并不是达到某种结果,结果都会死的.<br>过程最重要,一路上解决各种问题的过程,才是最珍贵的.</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂 synchronized</title>
      <link href="2023/02/23/3/"/>
      <url>2023/02/23/3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么禁用&quot;select * &quot;</title>
      <link href="2023/02/22/whynotstaet/"/>
      <url>2023/02/22/whynotstaet/</url>
      
        <content type="html"><![CDATA[<p>SELECT * 是一种 SQL 查询语句，表示从指定的表中选择所有列。虽然 SELECT * 可以返回表中的所有数据，但这种查询方法可能会导致一些问题：</p><p>不必要的网络流量：如果一张表有很多列，而且你只需要其中的一部分，使用 SELECT * 会将所有列的数据都传输到客户端，增加了不必要的网络流量。</p><p>减缓查询速度：如果查询的表中有很多列，而且你只需要其中的一部分，使用 SELECT * 可能会减缓查询的速度，因为数据库需要检索和传输多余的数据。</p><p>查询结果不可预测：如果表的结构发生了变化，例如增加或删除了一些列，使用 SELECT * 会返回新的结构，导致你的代码需要重新调整来适应这些变化。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建1000w测试数据</title>
      <link href="2023/02/21/testdatas/"/>
      <url>2023/02/21/testdatas/</url>
      
        <content type="html"><![CDATA[<p>假如需要创建1000w 测试数据的话,可以尝试使用存储过程.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;data&#96; </span><br><span class="line">(</span><br><span class="line">  &#96;id&#96;         bigint(20) NOT NULL      AUTO_INCREMENT,</span><br><span class="line">  &#96;datetime&#96;   timestamp  NULL          DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  &#96;channel&#96;    int(11)                  DEFAULT NULL,</span><br><span class="line">  &#96;value&#96;      float                    DEFAULT NULL,</span><br><span class="line"></span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE generate_data(IN n int)</span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE i INT DEFAULT 0;</span><br><span class="line">  WHILE i &lt; n DO</span><br><span class="line">    INSERT INTO &#96;data&#96; (&#96;datetime&#96;,&#96;value&#96;,&#96;channel&#96;) VALUES (</span><br><span class="line">      FROM_UNIXTIME(UNIX_TIMESTAMP(&#39;2014-01-01 01:00:00&#39;)+FLOOR(RAND()*31536000)),</span><br><span class="line">      ROUND(RAND()*100,2),</span><br><span class="line">      1</span><br><span class="line">    );</span><br><span class="line">    SET i &#x3D; i + 1;</span><br><span class="line">  END WHILE;</span><br><span class="line"></span><br><span class="line">  CALL generate_data(10000);</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>删除存储过程执行如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE generate_data;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存的本质和缓存实践</title>
      <link href="2023/02/20/cache/"/>
      <url>2023/02/20/cache/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要用缓存"><a href="#为什么要用缓存" class="headerlink" title="为什么要用缓存?"></a>为什么要用缓存?</h2><h3 id="缓存的本质"><a href="#缓存的本质" class="headerlink" title="缓存的本质"></a>缓存的本质</h3><blockquote><p>通俗理解计算机缓存,可以比喻成水库.</p></blockquote><h3 id="CPU缓存和系统机构缓存"><a href="#CPU缓存和系统机构缓存" class="headerlink" title="CPU缓存和系统机构缓存"></a>CPU缓存和系统机构缓存</h3><h2 id="缓存编程实现"><a href="#缓存编程实现" class="headerlink" title="缓存编程实现"></a>缓存编程实现</h2><h3 id="编程法"><a href="#编程法" class="headerlink" title="编程法"></a>编程法</h3><p>采用各种reis 客户端和 API.比如Jredis api</p><h3 id="Spring-注入"><a href="#Spring-注入" class="headerlink" title="Spring 注入"></a>Spring 注入</h3><p>Spring Data Redis 是 Spring Data 家族的一个项目，它为 Spring 应用程序提供了与 Redis 数据存储交互的支持。Spring Data Redis 通过 RedisTemplate 和 RedisConnectionFactory 为 Redis 提供了高级的 Redis 操作接口。</p><ul><li><p>添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>RedisTemplate源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">public void setValue(String key, Object value) &#123;</span><br><span class="line">    redisTemplate.opsForValue().set(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object getValue(String key) &#123;</span><br><span class="line">    return redisTemplate.opsForValue().get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>注入RedisTemplate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class RedisService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    public void setValue(String key, String value) &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue(String key) &#123;</span><br><span class="line">        return redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="注解法"><a href="#注解法" class="headerlink" title="注解法"></a>注解法</h3><p>如果你用 springboot,使用 @Cacheable 注解来实现 Redis 缓存非常简单，您只需要按照以下步骤即可：</p><ol><li><p>添加依赖：首先，在 pom.xml 文件中添加 spring-boot-starter-cache 和 spring-boot-starter-data-redis 依赖。</p></li><li><p>配置 Redis：在 application.properties 或 application.yml 文件中配置 Redis 连接信息。</p></li><li><p>创建缓存配置：在您的应用程序中创建一个缓存配置类，并使用 @Configuration 和 @EnableCaching 注解进行标注。在这个类中，您可以使用 CacheManagerBuilder.build() 方法来创建一个 RedisCacheManager 对象。</p></li><li><p>使用 @Cacheable：在需要缓存的方法上使用 @Cacheable 注解，指定缓存名称以及需要缓存的数据 key。<br>下面是一个使用 @Cacheable 注解来实现 Redis 缓存的示例：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @Cacheable(value &#x3D; &quot;user&quot;, key &#x3D; &quot;#id&quot;)</span><br><span class="line">    public User getUserById(Long id) &#123;</span><br><span class="line">        return userRepository.findById(id).orElse(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 其他业务方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问缓存的模式"><a href="#访问缓存的模式" class="headerlink" title="访问缓存的模式"></a>访问缓存的模式</h2><h3 id="双读双写"><a href="#双读双写" class="headerlink" title="双读双写"></a>双读双写</h3><p>一般采用这种写法<br><img src="https://user-images.githubusercontent.com/9412449/220018370-696f2a8d-440e-4a83-8d97-c7d058a5b362.png" alt="image"></p><h2 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h2><p><img src="https://user-images.githubusercontent.com/9412449/220019055-6353b1e1-80b4-473a-83d5-56df60182373.png" alt="image"></p><h2 id="串联模式"><a href="#串联模式" class="headerlink" title="串联模式"></a>串联模式</h2><p><img src="https://user-images.githubusercontent.com/9412449/220019109-48d675d4-fd23-44b0-887f-67e11772df34.png" alt="image"></p><!--  --><h2 id="分片模式"><a href="#分片模式" class="headerlink" title="分片模式"></a>分片模式</h2><h3 id="客户端分片"><a href="#客户端分片" class="headerlink" title="客户端分片"></a>客户端分片</h3><h3 id="代理分片"><a href="#代理分片" class="headerlink" title="代理分片"></a>代理分片</h3><h3 id="集群分片"><a href="#集群分片" class="headerlink" title="集群分片"></a>集群分片</h3><h2 id="迁移方案"><a href="#迁移方案" class="headerlink" title="迁移方案"></a>迁移方案</h2><h3 id="平滑迁移"><a href="#平滑迁移" class="headerlink" title="平滑迁移"></a>平滑迁移</h3><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何知识变现</title>
      <link href="2023/02/20/liquidate/"/>
      <url>2023/02/20/liquidate/</url>
      
        <content type="html"><![CDATA[<!-- ## 如何知识变现 --><p>1、利用社交媒体：利用社交媒体平台，如微博、微信、抖音等，发布有价值的内容，建立自己的知识品牌，吸引更多的粉丝，从而获得收益。</p><p>2、发布视频：利用视频平台，如优酷、腾讯视频等，发布有价值的视频，从而获得收益。</p><p>3、发布电子书：利用电子书平台，如亚马逊、当当等，发布有价值的电子书，从而获得收益。</p><p>4、开设在线课程：利用在线课程平台，如慕课网、网易云课堂等，开设有价值的课程，从而获得收益。</p><p>5、发布文章：利用文章发布平台，如简书、知乎等，发布有价值的文章，从而获得收益。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识变现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从难点中学习</title>
      <link href="2023/02/18/studyformdiffrence/"/>
      <url>2023/02/18/studyformdiffrence/</url>
      
        <content type="html"><![CDATA[<h2 id="先了解技术难点"><a href="#先了解技术难点" class="headerlink" title="先了解技术难点"></a>先了解技术难点</h2><p>先分析难点,基本会从以下开始:</p><p>有限的时间；<br>复杂的环境；<br>知识的盲区.<br>解技术难点的关键是深入了解它的背景，把它拆解成一个个具体的问题，把它拆解成一个个可以解决的小问题。</p><h2 id="寻找解决方案"><a href="#寻找解决方案" class="headerlink" title="寻找解决方案"></a>寻找解决方案</h2><p>可以通过搜索引擎、技术社区、技术文档等方式，寻找可以解决技术难点的解决方案。<br>向他人请教,这个会涉及到另一个问题 <strong>如何问问题?</strong></p><h2 id="如何问问题"><a href="#如何问问题" class="headerlink" title="如何问问题?"></a>如何问问题?</h2><ol><li><p>明确你要问的问题：先确定你要问的问题，确保你的问题清楚明确，不要模糊不清。</p></li><li><p>提出具体的问题：避免问题过于抽象，要把问题具体化，让对方能够清楚地理解你的问题。</p></li><li><p>尽量使用简短的问题：尽量使用简短的问题，避免太多的冗余信息，以免让对方感到困惑。</p></li><li><p>使用开放性问题：尽量使用开放性问题，这样可以让对方有更多的发挥空间，从而获得更多的信息。</p></li><li><p>注意问题的措辞：注意问题的措辞，避免使用过于激烈的语言，以免让对方感到压力。</p></li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>实践是学习的最佳方式，可以通过实践来加深对技术难点的理解，并且在实践中发现新的知识点。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习过程中，可以总结解决技术难点的方法，以便以后更好地解决类似的问题。最好能把解题思路和过程记录下来,分享给大家.势必会事半功倍!</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35岁程序员如何摆脱焦虑?</title>
      <link href="2023/02/17/anxiety/"/>
      <url>2023/02/17/anxiety/</url>
      
        <content type="html"><![CDATA[<h3 id="关注自己的发展"><a href="#关注自己的发展" class="headerlink" title="关注自己的发展"></a>关注自己的发展</h3><p>把时间花在提升专业技能和知识上，不断完善自己。</p><h3 id="调整好心态"><a href="#调整好心态" class="headerlink" title="调整好心态"></a>调整好心态</h3><p>经常反思自己，认识到自己的价值所在，把握自己的价值，掌控自己的发展方向。</p><h3 id="扩大自己的社交圈"><a href="#扩大自己的社交圈" class="headerlink" title="扩大自己的社交圈"></a>扩大自己的社交圈</h3><p>多交朋友，多参加行业聚会，扩大自己的人脉资源，让自己的人际关系多样化。</p><h3 id="找出自己的兴趣"><a href="#找出自己的兴趣" class="headerlink" title="找出自己的兴趣"></a>找出自己的兴趣</h3><p>可以尝试一些新的兴趣爱好，比如旅游、健身、画画等，可以让自己放松心情，让自己的心情变得更加愉悦。</p><h3 id="健康生活"><a href="#健康生活" class="headerlink" title="健康生活"></a>健康生活</h3><p>要注意身体健康，及时补充充足的睡眠，多吃健康的食物，多运动，保持正常的作息时间。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 焦虑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重启</title>
      <link href="2023/02/17/restart/"/>
      <url>2023/02/17/restart/</url>
      
        <content type="html"><![CDATA[<p>人生是一场漫长的旅程，每个人都会面临起伏不定的挑战和机会。有时候我们会因为失败而感到沮丧和失落，但是重启人生的机会总是存在的。重新奋斗的人生，就是向前迈出的第一步。</p><p>首先，要重启人生，我们需要改变自己的心态。我们需要意识到，过去的失败并不代表未来的失败，反而是一次宝贵的经验。我们需要从失败中吸取教训，了解我们可以做得更好的地方，并从中受益。我们需要坚信自己的能力和价值，并且不要害怕尝试新的事物。</p><p>其次，我们需要为自己设定目标，并采取积极的行动。我们需要制定清晰明确的计划，为自己设定短期和长期目标，并设定可以衡量自己进展的标准。我们需要认真思考自己的职业和生活目标，并为之努力奋斗。我们需要充满动力，不断向前迈进。</p><p>第三，我们需要积极学习和成长。学习是一辈子的事情，我们需要持续不断地学习新的知识和技能，以适应变化的世界。我们需要主动探索新的领域，并不断提高自己的技能水平。我们需要寻求并接受他人的帮助和建议，并为自己设定更高的目标，不断追求卓越。</p><p>最后，我们需要保持积极的心态。我们需要坚持自己的信念和价值观，克服困难和挑战，保持自信和勇气。我们需要积极面对挑战和失败，并且从中汲取力量和智慧。我们需要保持乐观和自信，不断努力，追求自己的梦想和目标。</p><p>总之，重新奋斗的人生充满了机遇和挑战。我们需要改变自己的心态，为自己设定目标，并积极行动。我们需要积极学习和成长，保持积极的心态，并坚信自己的能力和价值。最重要的是，我们需要始终保持决心和毅力，不断向前迈进，实现自己的梦想和目标。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的规划</title>
      <link href="2023/02/16/%E6%88%91%E7%9A%84%E5%8F%8D%E6%80%9D/"/>
      <url>2023/02/16/%E6%88%91%E7%9A%84%E5%8F%8D%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<p>我的规划</p><hr><p>认知升级：不断学习去升级认知，做更好的自己。<br>长期主义：做有长期收益的事情，比如写作与投资。<br>积极分享：分享个人经验积极影响他人。</p><p>![image-20210625103901356](/Users/houxiaoqiang/Library/Application Support/typora-user-images/image-20210625103901356.png)</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的规划</title>
      <link href="2023/02/16/target/"/>
      <url>2023/02/16/target/</url>
      
        <content type="html"><![CDATA[<p>我的规划</p><hr><p>认知升级：不断学习去升级认知，做更好的自己。<br>长期主义：做有长期收益的事情，比如写作与投资。<br>积极分享：分享个人经验积极影响他人。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0216 restart</title>
      <link href="2023/02/16/0216-restart/"/>
      <url>2023/02/16/0216-restart/</url>
      
        <content type="html"><![CDATA[<h1 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h1><p>xxxx</p>]]></content>
      
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 中的锁解决什么问题?</title>
      <link href="2023/02/15/java-%E4%B8%AD%E7%9A%84%E9%94%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"/>
      <url>2023/02/15/java-%E4%B8%AD%E7%9A%84%E9%94%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Java中的锁是一种同步机制，可以确保多个线程之间共享资源的互斥访问，从而避免出现数据竞争和线程安全问题。使用锁的主要目的是保证代码的正确性和可靠性。</p><p>Java中的锁能够解决以下实际问题：</p><p>数据竞争：在多线程环境中，如果多个线程同时访问共享数据，就会产生数据竞争问题。使用锁可以确保同一时间只有一个线程可以访问共享资源，避免数据竞争和数据不一致的问题。<br>线程安全：Java中的锁可以确保线程安全，避免多个线程之间的干扰和竞争，从而保证代码的正确性和可靠性。<br>性能优化：Java中的锁可以用于优化程序的性能，比如使用读写锁来实现对数据的读写分离，从而提高程序的并发性能。<br>死锁问题：Java中的锁可以用于避免死锁问题，比如使用一致性的加锁顺序，避免出现循环依赖的情况。<br>总之，Java中的锁机制是保证多线程并发安全的重要手段，可以用于解决数据竞争、线程安全、性能优化和死锁问题等实际问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java怎找工作</title>
      <link href="2023/02/15/java%E6%80%8E%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
      <url>2023/02/15/java%E6%80%8E%E6%89%BE%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>java 程序员怎么做找工作</p><p>在网络招聘网站上搜索职位。在中国，像智联招聘、前程无忧、猎聘网等招聘网站上，有许多公司在招聘JAVA程序员。通过这些网站可以快速找到自己合适的工作。</p><p>关注社交媒体和专业网站。<br>加入一些面向JAVA程序员的社交媒体和专业网站，如 CSDN、51CTO 等，并关注相关领域的微信公众号或QQ群。这些渠道可能会发布一些招聘信息，并且也能让您了解最新技术动态。</p><p>参加招聘会和技术交流会。<br>许多城市都会举办招聘会和技术交流会，这是一个很好的了解行业动态、与公司和招聘人员交流的机会。</p><p>向自己熟悉的人求助。<br>如果您有一些熟悉的朋友或前同事在相关公司工作，可以向他们求助，了解招聘情况和有关的信息。这也可能是找到合适工作的快捷方式。</p><p>通过自己的作品证明能力。<br>如果您已经有一些独立完成的项目或者参与的开源项目，可以在GitHub等平台上分享您的作品，向雇主展示自己的实际能力。</p><p>提高自身的技能和水平。保持不断学习和提升自身的技术能力和素养，可以增加自己在市场上的竞争力，并提高找到合适工作的机会。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot-docker</title>
      <link href="2023/01/07/springboot-docker/"/>
      <url>2023/01/07/springboot-docker/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-run-springboot"><a href="#docker-run-springboot" class="headerlink" title="docker run springboot"></a>docker run springboot</h1><h2 id="创建springboot-项目"><a href="#创建springboot-项目" class="headerlink" title="创建springboot 项目"></a>创建springboot 项目</h2><p>创建项目 从 <a href="https://start.spring.io/">https://start.spring.io/</a></p><p>启动类配置如下：<code>src/main/java/hello/Application.java</code></p><pre><code>package hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@SpringBootApplication@RestControllerpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;    //return current time    @RequestMapping(&quot;/time&quot;)    public String time() &#123;        return new Date().toString();    &#125;&#125;</code></pre><h2 id="docker-启动"><a href="#docker-启动" class="headerlink" title="docker 启动"></a>docker 启动</h2><h3 id="dockerfile-编写"><a href="#dockerfile-编写" class="headerlink" title="dockerfile 编写"></a>dockerfile 编写</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">ARG</span> JAR_FILE=target/*.jar</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$&#123;JAR_FILE&#125;</span> app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><ol><li>将app.jar拷贝到容器</li><li>引用 jdk</li></ol><h3 id="build-amp-run"><a href="#build-amp-run" class="headerlink" title="build&amp;run"></a>build&amp;run</h3><p><code>docker build -t ddx/demo</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">ddx/demo     latest    1b4b076fd19f   2 hours ago   122MB</span><br><span class="line">mysql        latest    7484689f290f   4 weeks ago   538MB</span><br><span class="line">jenkins      2.60.3    cd14cecfdb3a   4 years ago   696MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>docker run -p 8080:8080 </code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID   IMAGE      COMMAND                CREATED             STATUS             PORTS                    NAMES</span><br><span class="line">62fa2f9c4bfc   ddx/demo   <span class="string">&quot;java -jar /app.jar&quot;</span>   About an hour ago   Up About an hour   0.0.0.0:8080-&gt;8080/tcp hardcore_zhukovsky</span><br></pre></td></tr></table></figure><p>访问 localhost:8080/time</p><pre><code>➜  ~ curl localhost:8080/timeFri Jan 06 06:18:31 GMT 2023%</code></pre><p>本文参考： <a href="https://spring.io/guides/gs/spring-boot-docker/">https://spring.io/guides/gs/spring-boot-docker/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springmvcvswebflux</title>
      <link href="2023/01/06/springmvcvswebflux/"/>
      <url>2023/01/06/springmvcvswebflux/</url>
      
        <content type="html"><![CDATA[<p>Spring WebFlux 和 Spring MVC 对比分析</p><p>什么是 Spring WebFlux</p><p>Spring MVC is built on the Servlet API and uses a synchronous blocking I/O architecture whth a one-request-per-thread model.</p><p>Spring MVC 构建于 Servlet API 之上，使用的是同步阻塞式 I/O 模型，什么是同步阻塞式 I/O 模型呢？就是说，每一个请求对应一个线程去处理。</p><p>Spring WebFlux is a non-blocking web framework built from the ground up to take advantage of multi-core, next-generation processors and handle massive numbers of concurrent connections.</p><p>Spring WebFlux 是一个异步非阻塞式的 Web 框架，它能够充分利用多核 CPU 的硬件资源去处理大量的并发请求。</p><p>WebFlux 的优势&amp;提升性能?</p><p>Reactive and non-blocking generally do not make applications run faster.</p><p>WebFlux 并不能使接口的响应时间缩短，它仅仅能够提升吞吐量和伸缩性。</p><p>WebFlux 应用场景</p><p>PS: IO 密集型包括：磁盘IO密集型, 网络IO密集型，微服务网关就属于网络 IO 密集型，使用异步非阻塞式编程模型，能够显著地提升网关对下游服务转发的吞吐量。</p><p>选 WebFlux 还是 Spring MVC?</p><p>WebFlux 不是 Spring MVC 的替代方案！</p><p>首先是吞吐量</p><p>随着每个请求的被处理时间越长、并发请求的量级越大，WebFlux 相比 SpringMVC 的整体吞吐量高的越多，平均的请求响应时间越短。如下图所示</p><p>吞吐量大了，意味着单位时间内可以处理的请求数变多了，比如原来 1w 个请求 10 秒处理完，现在 10w 个请求也是 10 秒处理完，就代表吞吐上去了。注意，是吞吐上去了，不代表单次请求快了，单次请求的速度和原来一样。</p>]]></content>
      
      
      
        <tags>
            
            <tag> springmvc </tag>
            
            <tag> weblux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxb-奥密克戎</title>
      <link href="2023/01/06/xxb/"/>
      <url>2023/01/06/xxb/</url>
      
        <content type="html"><![CDATA[<p>XBB 奥密克戎的新版本，瞎哔哔 这病毒的名字起的真好!<br>依我看接下来疫情的走势，就冲这个名字大家一定能发大财！<br>如果人一旦正经八百，对结果很在意的时候，反而达不到预期的效果。<br>所以处在各行各业的你都要抱着瞎哔哔的心态，做好了赚钱了，是你牛批，做不好没赚到钱这一定是疫情搞得鬼！<br>作为打工人，也要保持瞎比比的松驰感，别人躺平我卷！别人卷的时候我躺平！<br>记住，瞎哔哔是一种人生态度！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 疫情 xbb 人间清醒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-generator-search</title>
      <link href="2023/01/06/test/"/>
      <url>2023/01/06/test/</url>
      
        <content type="html"><![CDATA[<p>生成搜索 data   Hexo  3。x   4. x。这个插件    用于生成  搜索索引 文件,  包含所有的必要  data    文章 你 可以使用 写 本地搜索引擎   博客。JSON支持  XML 和   输出格式。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-search --save</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果需要排除搜索，只要在indexing:false 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;Code Highlight&quot;</span><br><span class="line">date: &quot;2014-03-15 20:17:16&quot;</span><br><span class="line">tags: highlight</span><br><span class="line">categories: Demo</span><br><span class="line">description: &quot;A collection of Hello World applications from helloworld.org.&quot;</span><br><span class="line">toc: true</span><br><span class="line">indexing: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-generator-search</title>
      <link href="2023/01/06/hexo-generator-search/"/>
      <url>2023/01/06/hexo-generator-search/</url>
      
        <content type="html"><![CDATA[<p>生成搜索 data   Hexo  3。x   4. x。这个插件    用于生成  搜索索引 文件,  包含所有的必要  data    文章 你 可以使用 写 本地搜索引擎   博客。JSON支持  XML 和   输出格式。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-search --save</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果需要排除搜索，只要在indexing:false 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;Code Highlight&quot;</span><br><span class="line">date: &quot;2014-03-15 20:17:16&quot;</span><br><span class="line">tags: highlight</span><br><span class="line">categories: Demo</span><br><span class="line">description: &quot;A collection of Hello World applications from helloworld.org.&quot;</span><br><span class="line">toc: true</span><br><span class="line">indexing: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>juc-01</title>
      <link href="2023/01/06/juc/"/>
      <url>2023/01/06/juc/</url>
      
        <content type="html"><![CDATA[<h3 id="阶段1"><a href="#阶段1" class="headerlink" title="阶段1"></a>阶段1</h3><p>什么是JUC？<br>为什么CAS和AQS是JUC的核心？<br>ReentrantLock适用于什么场景？<br>门闩（Latch）同步器适用于什么场景？<br>篱笆（Barrier）同步器适用于什么场景？<br>信号量（Semaphore）同步器适用于什么场景？<br>阶段同步器（Phaser）适用于什么场景？<br>原生锁支持（LockSupport）适用于什么场景？<br>有哪些同步队列可以用于线程池？<br>Exchanger交换器适用于什么场景？<br>各种同步器在大厂面试中的综合运用怎么做？<br>（首次公开）通过阿里一道面试题理解大厂面试多线程代码题的要求<br>02.赢在2021年金三银四的起跑线上</p><p>什么是JUC？什么是JUC？什么是JUC？什么是JUC？什么是JUC？什么是JUC？<br>为什么CAS和AQS是JUC的核心？<br>ReentrantLock适用于什么场景？<br>门闩（Latch）同步器适用于什么场景？<br>篱笆（Barrier）同步器适用于什么场景？<br>信号量（Semaphore）同步器适用于什么场景？<br>阶段同步器（Phaser）适用于什么场景？<br>原生锁支持（LockSupport）适用于什么场景？<br>有哪些同步队列可以用于线程池？<br>Exchanger交换器适用于什么场景？<br>各种同步器在大厂面试中的综合运用怎么做？<br>（首次公开）通过阿里一道面试题理解大厂面试多线程代码题的要求<br>02.赢在2021年金三银四的起跑线上</p><h3 id="阶段2"><a href="#阶段2" class="headerlink" title="阶段2"></a>阶段2</h3><p>线程的本质(操作系统与CPU是如何执行线程的)<br>并发编程为什么充满挑战？<br>并发编程的三大特性：可见性、有序性、原子性<br>synchronized JMM CAS AQS lock这些高频出现的面试概念究竟是什么？<br>无锁、偏向锁、轻量级锁、重量级锁升级过程<br>悲观锁/乐观锁 共享锁/独占锁 整体锁/分段锁 可重入锁/不可重入锁<br>（首次公开）银弹已经诞生？有没有一种一定能保证线程安全的终极代码？<br>（首次公开）工作线程数，设多少最合适？如何理解N<em>C</em>(1+C/W)的计算公式?</p>]]></content>
      
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="2023/01/06/idea%20always%20Update%20Indices/"/>
      <url>2023/01/06/idea%20always%20Update%20Indices/</url>
      
        <content type="html"><![CDATA[<h1 id="idea-always-Update-Indices"><a href="#idea-always-Update-Indices" class="headerlink" title="idea always Update Indices"></a>idea always Update Indices</h1><h2 id="Open-IntelliJ-IDEA"><a href="#Open-IntelliJ-IDEA" class="headerlink" title="Open IntelliJ IDEA."></a>Open IntelliJ IDEA.</h2><ol><li>Select the File menu.</li><li>Select the Invalidate Caches / Restart… menu. Once selected you get a pop-up with a bunch of options.</li><li>Select Invalidate and Restart. and before doing that make sure you saved all your changes else it might delete some unsaved changes.</li></ol>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot-docker-demo</title>
      <link href="2023/01/05/springboot-docker-demo/"/>
      <url>2023/01/05/springboot-docker-demo/</url>
      
        <content type="html"><![CDATA[<p> docker run springboot</p><h2 id="创建springboot-项目"><a href="#创建springboot-项目" class="headerlink" title="创建springboot 项目"></a>创建springboot 项目</h2><p>创建项目 从 <a href="https://start.spring.io/">https://start.spring.io/</a></p><p>启动类配置如下：<code>src/main/java/hello/Application.java</code></p><pre><code>package hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@SpringBootApplication@RestControllerpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;    //return current time    @RequestMapping(&quot;/time&quot;)    public String time() &#123;        return new Date().toString();    &#125;&#125;</code></pre><h2 id="docker-启动"><a href="#docker-启动" class="headerlink" title="docker 启动"></a>docker 启动</h2><h3 id="dockerfile-编写"><a href="#dockerfile-编写" class="headerlink" title="dockerfile 编写"></a>dockerfile 编写</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">ARG</span> JAR_FILE=target/*.jar</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$&#123;JAR_FILE&#125;</span> app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><ol><li>将app.jar拷贝到容器</li><li>引用 jdk</li></ol><h3 id="build-amp-run"><a href="#build-amp-run" class="headerlink" title="build&amp;run"></a>build&amp;run</h3><p><code>docker build -t ddx/demo</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">ddx/demo     latest    1b4b076fd19f   2 hours ago   122MB</span><br><span class="line">mysql        latest    7484689f290f   4 weeks ago   538MB</span><br><span class="line">jenkins      2.60.3    cd14cecfdb3a   4 years ago   696MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>docker run -p 8080:8080 </code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID   IMAGE      COMMAND                CREATED             STATUS             PORTS                    NAMES</span><br><span class="line">62fa2f9c4bfc   ddx/demo   <span class="string">&quot;java -jar /app.jar&quot;</span>   About an hour ago   Up About an hour   0.0.0.0:8080-&gt;8080/tcp hardcore_zhukovsky</span><br></pre></td></tr></table></figure><p>访问 localhost:8080/time</p><pre><code>➜  ~ curl localhost:8080/timeFri Jan 06 06:18:31 GMT 2023%</code></pre><p>本文参考： <a href="https://spring.io/guides/gs/spring-boot-docker/">https://spring.io/guides/gs/spring-boot-docker/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>one day</title>
      <link href="2022/11/04/one-day/"/>
      <url>2022/11/04/one-day/</url>
      
        <content type="html"><![CDATA[<p>1988年7月15日，一所大学为毕业生的狂热所充盈。籍着这股躁动，轻浮的德克斯特（吉姆·斯特吉斯 Jim Sturgess 饰）穿过层层人墙，寻找可以与之共度这最后狂欢与浪漫之夜的尤物。他将目光锁定在艾玛（安妮·海瑟薇 Anne Hathaway 饰）的身上，一个来自普 通工薪家庭的聪慧女孩。然而短短的交流过后，他们之间什么也没发生，却又注定改变了彼此的一生。在之后的岁月里，两人以友人知己的身份时聚时散，彼此分享着人生的苦辣酸甜和各种感悟。德克斯特经历着事业和婚姻的起落，艾玛品味着底层人生的辛酸。他们是远在天边心也紧紧相连的知己，是深锁心中最为笃真却相隔最远的爱恋……</p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>money</title>
      <link href="2021/05/18/money/"/>
      <url>2021/05/18/money/</url>
      
        <content type="html"><![CDATA[<p>文|自媒体：萌萌的猪猪侠。欢迎大家关注订阅我。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/3ue3ibjeAauKnicZA7hslOibsCKWOKicpDNtYTJZbaMJZIdToLovAA9JdZiaQIs7NTJVyQHQVJDicET47HcRE0bs0ZEA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>萌大，你昨天的文章有标题党之嫌。</p><p>我：是吧，但这是句实话。基金投资并不是适合每个人的，也不是每个人参与就能赚钱。即便是跟投组合，其实自主权还是在你自己手里，如果你不能坚持、坚定，遇到小波澜，大风浪就清仓，那确实没有机会享受风雨之后的彩虹。</p><p>说几个指标，供大家参考。</p><p>第一，创业板昨日涨幅2.6%，突破了前期高点。这个与我之前的研判不一致，我设想的是创业板可能会继续下跌回调。再次验证了普通投资者很难预测短期的走势，前几天清仓创业板，加仓新能源标的，从目前这几天的表现来看，还行，算是操作对了。创业板50指数中，也是重仓新能源板块的，只是我们通过转换，更明确的提高了新能源板块的配置比例。</p><p>第二，近两日成交量有所提高，虽然不及年初，但也有回暖的趋势。创业板成交量1870亿元，上证指数成交量4244亿元，深证成指成交量5055亿元，总成交量过万亿。我想，今天大家还是期望继续涨，这就是赚钱效应。</p><p>第三，萌萌的猪猪侠国内组合通过昨天的大涨，今年亏损基本收复（期间加大定投额度，功不可没），大概还亏不到两千元，距离赚钱，仅仅一步之遥。一般这个时候，市场可能就要回调一下。这是我的猜想，我也希望这个猜想，继续被打脸，毕竟赚钱是让所有人都开心的事儿。</p><p>第四，昨天的文章不知道是不是因为标题的原因，阅读量创下了近期的新高，从阅读指数上来说，体现了市场的好转。如果明天阅读量继续提高，那看来大多数人都开始赚钱了。阅读量背后，就是人心，人心就是市场。</p><p>几个板块的分析。</p><p>消费板块，以白酒和食品饮料为主，继续看好和持有。必选消费保持持仓比例，按期定投。</p><p>上证50指数，比如持仓的易方达上证50指数，前段时间回调幅度较大，有朋友问是否单独补仓，我觉得没有必要。按计划定投吧。上证50的定位就是压舱石，压舱石有就行了，不用刻意增加。</p><p>新能源板块，通过前段时间的加仓，比例也差不多了，继续持有，让子弹飞一会。目前，农银新能源主题还亏3%，汇添富中证新能源汽车，已经持平。浦银安盛新经济结构混合已经开始赚钱。</p><p>国寿安保策略精选混合，兑现了新能源标的收益，整体风格偏向防御。我本来寻思是不是得换个先锋，转念一想，有人当前锋就得有人当后卫，何况我目前持有这个标的，能当后卫，也有能力当前锋呢。去年7月的时候，吴总还是有很超前的意识，提前布局了新能源。这次，我继续观察，期待。</p><p>嘉实港股通新经济指数A和交银中证海外中国互联网指数基金最近在历劫，既然是历劫，就有扛过去的时候。前者，我们继续保持现有仓位，配合对冲。中概互联，最近无法加仓，我们会加仓萌萌的猪猪侠海外组合中其他标的，通过被动方式适度降低中概互联持仓比例。</p><p>汇报完毕，投资有风险，入市需谨慎。不要因为这两天赚了点钱就开始冒进，往前冲。日子还长，慢慢来，星辰大海，无我利他，我们一起冲鸭！</p><p>分享、点赞、在看 顺手三连越来越有钱！</p><p>喜欢，记得关注，分享我们的微信公众号：萌萌的猪猪侠。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 挣钱 </tag>
            
            <tag> 内容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用springboot写一个 demo</title>
      <link href="2021/02/18/hello-springboot/"/>
      <url>2021/02/18/hello-springboot/</url>
      
        <content type="html"><![CDATA[<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><ol><li>创建一个 Maven 项目，并在 pom.xml 中添加以下依赖：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="创建主程序"><a href="#创建主程序" class="headerlink" title="创建主程序"></a>创建主程序</h2><ol start="2"><li>创建一个 Spring Boot 应用程序类，例如 App.java，并使用 @SpringBootApplication 注解来声明它是一个 Spring Boot 应用程序：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建-controller"><a href="#创建-controller" class="headerlink" title="创建 controller"></a>创建 controller</h2></li><li>创建一个 Controller 类，例如 HelloController.java，并使用 @RestController 和 @RequestMapping 注解来声明一个 RESTful 接口：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>运行应用程序，访问 <a href="http://localhost:8080/hello%EF%BC%8C%E4%BD%A0%E5%BA%94%E8%AF%A5%E8%83%BD%E7%9C%8B%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA">http://localhost:8080/hello，你应该能看到浏览器显示</a> “Hello World!”。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你真的会用reids吗？</title>
      <link href="2020/12/18/redisabout/"/>
      <url>2020/12/18/redisabout/</url>
      
        <content type="html"><![CDATA[<h1 id="你真的会用redis吗？"><a href="#你真的会用redis吗？" class="headerlink" title="你真的会用redis吗？"></a>你真的会用redis吗？</h1><p>什么时候用redis呢?</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存现在是几乎每个中大型网站的比啥技。合理的利用缓存不仅能提升网站的访问速度，还能大大降低数据库压力。 redis的key-value键值过期机制， 提供了灵活的键淘汰策略 ，所以redis应用场景特别的多。</p><h2 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h2><p>很多网站都有排行榜，如京东的月度销量，商品的最新排行。 redis提供的有序集合数据类型能实现各种复杂排行榜的应用。 </p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>什么是计数器？<br>电商网站的浏览量、视频的播放量 。为了保证实时有效，每次浏览都得+1. 而此时如果并发量比较高的，每次访问数据库 无是种挑战和压力。</p><p>redis提供的incr命令来实现计数器，内存操作性能非常好。</p><p>非常适用于这种场景。</p><h2 id="分布式会话"><a href="#分布式会话" class="headerlink" title="分布式会话"></a>分布式会话</h2><p>集群模式下，在应用不多的情况下，一般使用容器自带的session复制功能就能满足，当应用相对复杂的系统中，就会搭建以redisd等内存数据库为中心的缓存session服务 ，redis 不再由容器管理，而是ssession服务以及内存管理。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>很多互联网技术中都实现了 分布式技术。</p><p>分布式技术带来的技术挑战是对同一个资源的并发访问， 如全局id，减库存，秒杀场景。</p><p>并发量不大的场景可以使用乐观锁，悲观锁。但是并发量高的场合中，数据路锁的思路不太理想，降低了db的性能。</p><p>我们这时候可以利用redis的setnx 编写分布式的锁。如果设置返回 1 说明设置成功，否则获取锁失败。</p><h2 id="社交网络"><a href="#社交网络" class="headerlink" title="社交网络"></a>社交网络</h2><p>点赞 踩 关注/被关注 共同好友等社交网络基本要求下，传统的关系数据库很难存储。 </p><p>redis提供的哈希、集合等数据结构能很方便的实现这些功能</p><h2 id="最新列表"><a href="#最新列表" class="headerlink" title="最新列表"></a>最新列表</h2><p>Lpush可以在列表头部插入一个内容id作为关键字， LTRIM可以限制数量。这样列表永远为n个id，无需查询最新的列表，直接根据id去找对应的内容即可</p><h2 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h2><p>MQ-消息队列是大型网站必备的中间件。 主要用于业务解耦 流量削峰及异步处理，可实现简单的消息系统。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis，缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="2020/12/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/12/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="水电费dd"><a href="#水电费dd" class="headerlink" title="水电费dd"></a>水电费dd</h2><h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 挣钱 </tag>
            
            <tag> 内容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搬运内容挣钱怎么了</title>
      <link href="2020/12/05/%E6%90%AC%E8%BF%90%E5%86%85%E5%AE%B9%E6%8C%A3%E9%92%B1%E6%80%8E%E4%B9%88%E4%BA%86/"/>
      <url>2020/12/05/%E6%90%AC%E8%BF%90%E5%86%85%E5%AE%B9%E6%8C%A3%E9%92%B1%E6%80%8E%E4%B9%88%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h3 id="搬运赚钱是最简单的"><a href="#搬运赚钱是最简单的" class="headerlink" title="搬运赚钱是最简单的"></a>搬运赚钱是最简单的</h3><p>搬运分很多种，比如把国内视频搬到国外，国外搬到国内，说到把国外内容搬到国内最有名的平台就是煎蛋网，就是把国外一些有用、有趣的文章，翻译成中文发到网站上。</p><p>这是抄袭吗？我只知道<strong>它的内容在搜索引擎看来就是原创。</strong></p><p>其中油管上还是相当多的好东西，去油管搞个账号去，讲gu票的，一般千次播放的单价在5美金往上。</p><p><img src="https://pic4.zhimg.com/80/v2-6d4974d287306f4800c1812929ad27c3_720w.jpg" alt="img"></p><p>油管上凡是跟钱，财经，商业故事有关的，千次播放的单价都挺高的，因为投广告的，都是有钱的主，游戏类的，金rong财经类的，单价都高。</p><p>但是切记不能搬运，版权识别厉害，去抖音找一些小众的博主，模仿他的文案。</p><p>这里肯定有很多人怕讲中文用户看不懂，其实想多了，中文人口基数有这么大，国外的华人，香G，台湾的人，都喜欢上油管，包括脱口秀大会，搬运到油管上的，很多都过百万播放。</p><p>比如下面这个就是讲中文也有几百万订阅的。期期视频都是上百万，这是做得特别好的。</p><p><img src="https://pic1.zhimg.com/80/v2-8b5ce7b7be42bc8ce8b9faff5ca0f8dc_720w.jpg" alt="img"></p><p>以及A平台搬到B平台的社交网站或自媒体上，比方你在头条发了个文章，别人在另外几十个平台搬运你文章，平台只会根据本平台有没有相似内容来判断是否原创，不可能全网跨平台去检查，毕竟每天N多内容要审核，人工成本太大了。</p><p>还有把公众号内容搬到头条，个人网站上，把文章变成音频、视频、图片、书籍。</p><p>另外想让这些内容价格翻倍的话？得走专业化、课程化、订制化路线。</p><p>说一下，在17、18年很多人通过这个方式赚了点小钱，开始组建工作室批量操作，或者在网上找几个会剪辑的人，用类似有专自媒体这种软件去分发各大平台，赚平台的收益分成。</p><p><img src="https://pic2.zhimg.com/80/v2-3386aee70ee0c7bfed737c9d7c237835_720w.png" alt="img"></p><p>特别是电影剪辑视频最容易火，现在依旧存在，只是都发抖音、快手，西瓜视频，哔哩哔哩上了。</p><p>当然搬运是有一定技巧的，比如要先修改视频的一些编码参数，具体操作搜网上，有相关教程。</p><p>但从长久来讲，推荐大家先去做伪原创，严格来讲也算原创，看你二次修改到什么程度，在写的过程中，已经开始建立了你的知识体系，后面看到相关的文章内容，你就能脱口而出，因为这些知识你看过并掌握了，就属于原创了。</p><h3 id="让你们上来就写原创是非常不现实，但有捷径"><a href="#让你们上来就写原创是非常不现实，但有捷径" class="headerlink" title="让你们上来就写原创是非常不现实，但有捷径"></a>让你们上来就写原创是非常不现实，但有捷径</h3><p>1、把国外的文章，翻译后，再用你理解的二次加工就OK了。</p><p>2、把音频、视频平台，用讯飞语记根据声音转化成文字，还有公众号、Q空间、朋友圈好友发布的内容，某信群别人发的聊天内容、文章，都能整理或二次修改成一篇文章，对于搜索引擎，就是原创首发。</p><p>别觉得是我无耻，很多<strong>十万、百万大号都是从模仿做起来的，算是行业潜规则了。</strong></p><p>就拿我们上学，也是要朗读名著、别人的优秀十佳作文？，课本内容都统一，老师还鼓励我们要向文章写得好的同学去学习，本质上也是模仿。</p><p>就是先让你阅读一定基础量的文章，渐渐形成知识体系，再用你理解的讲出来，<strong>如果非要说是抄袭，那大家从小到大都在抄袭，只不过有的人抄得比较厉害罢了。</strong></p><p>其中，我建议搬运或二次修改到个人网站上，因为网站是你的，自个儿说了算，最多就删文章，或者找那些不出名的读者，一起运营或买下其版权，也是个低成本高效的方法，再不济雇几个大学生伪原创，一天十篇太简单了。</p><p>生意的本质就你不知道，<strong>我知道就能赚你钱，如一个产品换个地方卖，价格就上来了。</strong></p><p>再比如一篇国外文章在国外很多人知道，发到国内，至少99%的人不知道，更别说看过原文。</p><p>最重要的是行动。很多人都是整天想搞钱，但就只是躺在床上想，想了一个又一个项目，就是不行动。</p><p>如果我没猜错，很多人看完这篇文章后心里想：又是一推大道理和废话！</p><p>接着<strong>退出屏幕主页面，打开还没看完的电视剧、短视频。</strong></p><p>互联网上赚钱就是把东边的东西弄到西边卖，西边弄到东边卖，只是有的人搬得很厉害。</p><p>赚钱是简单的，很多人总追求所谓捷径和技巧，总忘记<strong>执行力才是最好的技巧</strong>。</p><p>最后说下如何把<strong>风险规避到最小？</strong></p><p>1、抄死人的作品。</p><p>2、古代N年前的作品。</p><p>3、抄国外，不说现在，即使以后，99%的人都不会刷到国外的文章。</p><p>4、抄量级小、没啥影响力的个人创作者，比如我……</p><p>就是作者本身没啥牛逼的实力，前期你抄他，维权成本高，懒得去管你，但后期你模仿他赚到钱，跟他打招呼说下，发个红包表达下心意，懂点人情世故的都不会去追究，毕竟新人的处境，我都懂。</p><p>至于如何变现？在这个内容+流量为王的时代，根本不愁没法变现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 挣钱 </tag>
            
            <tag> 内容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加仓了</title>
      <link href="2020/11/27/jc/"/>
      <url>2020/11/27/jc/</url>
      
        <content type="html"><![CDATA[<p>【加仓计划】2020年11月26日<br>今天市场，走的有点纠结，或者说大开大合。以上证指数为例，虽然幅度不大，但是看日线还是有较大振幅，多空博弈厉害。<br>美国大选结束，紧张的贸易战稍微缓和，但从长期看，不会有实质改善。这个预期大家要有。<br>市场博弈完，再看看最终方向选择吧。<br>持续的下跌，我发现大多数朋友心态不错，比我预期的要好很多。<br>今日加仓操作:<br>萌萌的猪猪侠国内组合，<br>加仓国寿安保稳惠混合基金200元。<br>加仓华安创业板50ETF联接A300元。<br>加仓浦银安盛医疗健康混合400元。<br>加仓工银深证红利ETF联接A200元。<br>猪猪侠随心投组合，一键买入1000元。<br>萌萌的猪猪侠海外组合，无操作。</p><p>via  <a href="https://mp.weixin.qq.com/s/HMPZ6YJU75RENaQf96x41A">萌萌的猪猪侠</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 关灯吃面 </tag>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安安稳稳吃碗面</title>
      <link href="2020/11/26/gdcm/"/>
      <url>2020/11/26/gdcm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>下跌是一面照妖镜</p></blockquote><p>基金赚了钱应不应该拿来消费？<br>我觉得因人而异，如果你指望通过基金赚钱来改善生活，那你的投资心态不可能太好，因为你亏不起。基金下跌的时候，每下跌一点，亏掉的可能就是你很长时间的生活费。所以我们给出的建议是不要拿生活费来投资，必须得用闲钱投资。<br>我们之所以没有考虑减仓基金，之前也分享过，主要是因为我们本职工作的收入已经可以让我们过得挺好了，我不指望基金投资的这笔钱，来生活来养家，所以面临下跌的时候，我的心态会更加平和，会觉得这是机会而不是风险。此外 从长期看，做好基金投资，收益真不错。<br>下跌是一面照妖镜，照出的是投资者内心的恐慌，担忧，愤怒和不满。月有阴晴圆缺，天有不测风云，市场有风险，投资需谨慎。<br>好了，今天的分享就到这里，喜欢我们的朋友可以给我们点个赞，点个在看，也可以分享给更多的朋友，邀请大家和我们一起跟投，一起走向财富自由</p>]]></content>
      
      
      
        <tags>
            
            <tag> 关灯吃面 </tag>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="2020/11/26/hello-world/"/>
      <url>2020/11/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>996是福报?</title>
      <link href="2020/11/25/1-1/"/>
      <url>2020/11/25/1-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>996是福报？还是送命福？</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 100 </tag>
            
            <tag> 吐槽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两件小事</title>
      <link href="2020/11/25/2/"/>
      <url>2020/11/25/2/</url>
      
        <content type="html"><![CDATA[<p>本文围绕两件事</p><blockquote><p>被偏爱的总是有恃无恐</p></blockquote><p>第一件是我拿可爱的女儿。宝宝开始喃喃自语，好像是在叫爸爸了，看着她一点点开始变大，心里很高兴，也很害怕，她慢一些长大吧。 于司令晚上也跟我投诉，“你家嘟嘟越来约不乖了”。我问咋了？她一脸委屈的跟我诉苦，”你家嘟嘟咬我咪咪可疼了，昨晚给我咬哭了“。哈哈哈。我说下次你揍她，就说我让的。</p><blockquote><p>窗外不只风景，还有你和未来的视界</p></blockquote><p>第二件事，跟于司令一起张罗搬家买点必须零碎，昨晚闹还闹得不欢而散，今晚一起出谋划策，畅所欲言，虽然不是给自己的房子置办，起码也是一起的小窝吧，于司令一直期望一个温馨的小家，此时北漂的我们来说，虽然有些苦难，但是只要我们在一起努力，终究会实现。感谢于司令的包容和鼓励。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 100 </tag>
            
            <tag> Grow up </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两件小事</title>
      <link href="2020/11/25/towthings/"/>
      <url>2020/11/25/towthings/</url>
      
        <content type="html"><![CDATA[<p>本文围绕两件事</p><blockquote><p>被偏爱的总是有恃无恐</p></blockquote><p>第一件是我拿可爱的女儿。宝宝开始喃喃自语，好像是在叫爸爸了，看着她一点点开始变大，心里很高兴，也很害怕，她慢一些长大吧。 于司令晚上也跟我投诉，“你家嘟嘟越来约不乖了”。我问咋了？她一脸委屈的跟我诉苦，”你家嘟嘟咬我咪咪可疼了，昨晚给我咬哭了“。哈哈哈。我说下次你揍她，就说我让的。</p><blockquote><p>窗外不只风景，还有你和未来的视界</p></blockquote><p>第二件事，跟于司令一起张罗搬家买点必须零碎，昨晚闹还闹得不欢而散，今晚一起出谋划策，畅所欲言，虽然不是给自己的房子置办，起码也是一起的小窝吧，于司令一直期望一个温馨的小家，此时北漂的我们来说，虽然有些苦难，但是只要我们在一起努力，终究会实现。感谢于司令的包容和鼓励。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 100 </tag>
            
            <tag> Grow up </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Can&#39;t set cookie dm_task_set_cookie failed 错误处理</title>
      <link href="2020/11/25/1/"/>
      <url>2020/11/25/1/</url>
      
        <content type="html"><![CDATA[<p>Can’t set cookie dm_task_set_cookie failed</p><p>解决：<br>0.到出错误的 服务器 上<br>1.docker ps 查出当前所有运行的 docker 容器，记下来id<br>2.关闭docker服务<br>echo ‘y’ | sudo dmsetup udevcomplete_all<br>3.重启docker服务<br>systemctl restart docker<br>4.依次<br>docker restart  id </p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Can&#39;t set cookie dm_task_set_cookie failed 错误处理</title>
      <link href="2020/11/25/dm_task_set_cookie/"/>
      <url>2020/11/25/dm_task_set_cookie/</url>
      
        <content type="html"><![CDATA[<p>Can’t set cookie dm_task_set_cookie failed</p><p>解决：<br>0.到出错误的 服务器 上<br>1.docker ps 查出当前所有运行的 docker 容器，记下来id<br>2.关闭docker服务<br>echo ‘y’ | sudo dmsetup udevcomplete_all<br>3.重启docker服务<br>systemctl restart docker<br>4.依次<br>docker restart  id </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
